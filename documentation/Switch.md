# Motivation
The `Switch` component allows to associate a set of values from a source (called switch source) to a component. When the switch source emits the values associated to a given component, that component is activated (switched on). Components which are not associated to the emitted set of values are deactivated (switched off).

The `Switch` component can be viewed as a single-state state machine, whose only event source is the switch source and event guards are the predicates specifying the component matching.

Practically speaking, the `Switch` component allows to improve separation of concerns by removing control flow out of some component designs. For instance, supposing we have a component whose behaviour depends on a discretizable parameter, in addition to other parameters, we need to write the logic corresponding to each discrete value in the body of the same function. With `Switch`, we can write several components corresponding to the logic for each discrete value separately.

For example, a component might be specified to display a product page when the user is logged in, and otherwise display a login page. This component hence has two behaviors or concerns which are unrelated. The discrete values here can be thought of as `LOGGED_IN`, `NOT_LOGGED_IN`. With `Switch`, we can write a `Login` component separately and independently from the `Product` component, and let the `Switch` component activate the right component.

Note that this makes less sense when the isolated concerns are not independent. For instance, a `Product` component which displays a product details page for a given product would not be a good fit for usage of the `Switch` component, even if one can discretize products by product ids. The code for displaying a given product id, being the same for any product, using `Switch` would lead to code duplication, violating the DRY principle.

# API

## Switch :: SwitchSettings -> [CaseComponent] -> SwitchComponent

### Description
Creates a switch component whose behaviour is parameterized via `SwitchSettings`. Children components are the components to be mapped to incoming values on the switch source.

The parametrization is as follows :

- an array of sink names must be passed to indicate which sinks are to be extracted from the case components. Sinks produced by any child component which are not in the sink names array will be ignored. It is not necessary, for any sink name in that array, for a child component to return a sink of that name.
- the switch source can be specified in two ways :
	- the name of the source can be given as a string
	- a function can be used to compute the switch source from `sources` and `settings` parameter of the switch component (i.e. the component returned after application of the `Switch` combinator).

The behaviour is as follows :

- for every incoming value of the switch source, all predicates found in children `CaseComponent`s are executed. 
- The components associated to the fulfilled predicates are switched on
	- they receive the triggering value of the switch source as settings, in the property configured in `as`
	- **note that the parent component does not receive such value as it is upper in the hierarchy**
- The other components are switched off
- If there is a incoming value on the switch source such that there is no matching case, then all components are deactivated
	- the DOM for the parent component will still be activated, even as there will be no children DOM content
	- in the absence of a DOM content for the parent component, then an empty `<div></div>` will be issued. This is necessary to remove the formerly displayed DOM nodes from the DOM.


### Types
- `SwitchComponent :: Component`
-  `CaseComponent :: Component`
- `SwitchSettings :: Record {`
- `  sinkNames :: [String]`  **Mandatory**
- `  on :: SwitchOnCondition | SwitchOnSource` **Mandatory**
- `  as :: String` **Mandatory**
- `  eqFn :: T -> T -> Boolean` **Optional**
- `}`
- `SwitchOnCondition :: Sources -> Settings -> Source`
- `SwitchOnSource:: SourceName`
- `SourceName :: String`

### Contracts
- children component MUST be `CaseComponent`, i.e. generated by the `Case` combinator
- if the switch source is specified by name, then that source name MUST be found as a property of the `sources` parameter


## Case:: CaseSettings -> [Component] -> CaseComponent
### Description
The `Case` combinator returns a case component and is to be used solely in combination with the Switch combinator. 

It specifies a match between a value of a switch source and a component to be switched on. The match is specified by the property `when` in settings. Equality between two values can also be evaluated via a custom function passed in the `eqFn` property in settings.

Every case component  will receive when executed the property `switchedOn` as part of its settings. That property will be the incoming value of the switch source triggering the case component.

All `Case` component functions are executed for each incoming value. This means that case component functions will be activated for each matching incoming value. 

### Types
-  `CaseComponent :: Component`
- `CaseSettings :: Record {`
- `  when :: Object`  **Mandatory**
- `  eqFn :: T -> T -> Boolean` **Optional**
- `}`

### Contracts
- type contracts

# Example


# Tips
- Note that the switch predicates are evaluated every time there is an incoming value on the switch source. If it is necessary to implement a logic by which the component switching should only trigger on **CHANGES** of the incoming value, that logic could be implemented with appending a `distinctUntilChanged` to the switch source.
- One should strive for having a relatively low number of discretized switch values as there is a performance cost which is linear with the number of such values. As a matter of fact, all predicates matching switched components to their discretized values are executed, for every incoming value of the switch source.
- One can have several fulfilled predicates for a given incoming value of the switch source. This means that several components could be activated for a given incoming value, but different conditions, which allows to implement more complex logic. This is however to use wisely, as the ability to reason about behaviour suffers somewhat. For instance, when several components can be activated for the same incoming value, and order of activation of those component matter, such ordering requirement is essentially hidden as implementation detail in the source code.
- One can also implement a `eqFn` such that a `Case` component is activated for a set of values instead of just one value. Alternatively, a `on` source can be computed in a way that assign a unique identifier to a given set of values. Using `eqFn` should however be more versatile, as one can specify a different `eqFn` for each `Case` component.
