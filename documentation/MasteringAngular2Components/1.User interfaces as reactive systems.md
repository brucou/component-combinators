# User interfaces as concurrent reactive systems
As the name suggests, user interfaces allow a user to interface with other systems, with the idea that this interface will present some sought-for advantages vs. direct interaction with the mentioned systems : enhanced productivity, learnability, discoverability, etc. TODO : find references. 

For instance, when the interaction between systems become too complex (too many commands or sequence of commands, too many parameters, outputs difficult to exploit in their raw form, etc.), a user interface can help to reduce the cognitive load and the risk of errors on the user side. As a trivial example, while it is possible for a travel agent to interact directly with the reservation system, doing so through a well-designed user interface allows to have agents with little knowledge of the intricacies of the underlying system. They can focus instead on mastery of their specific domain (packages, customer segments, etc.) and the corresponding user stories, reflected in the user interface (book a flight, cancel a hotel, etc.).

The user expresses an intent through some means (key presses, vocal entry, etc.) with a view to realize a pre-existing action on the interfaced systems. Hence user interfaces are reactive systems almost by nature. 

They are additionally concurrent systems, as the user can continue to send orders through the user interface without waiting for the order to be completed. As such, user interface programming has the added complication of handling concurrency, both at a system and user interface level. 

Any specification and implementation techniques for user interfaces must then specify a reactive function, and the concurrent behaviour of the system.

## Specification and implementation techniques
In all what follows, it will be implicit that `event` and `action` are representations of the corresponding entities, i.e. not the actual events or actions, whatever that be, but symbols for those.

Functional and technical specifications for reactive systems must allow to extract :

- a relation between events and actions such that `event ~ action`, where
	- `~` is called the reactive relation
	- event is an event triggering an action by the user interface. Events can be
		- user-initiated
		- system-initiated i.e. generated by the environment or external world
- an interface with the systems through which actions intended by the user must be performed
- an interface by which the reactive system receives its events

Because most reactive systems are stateful, the relation `~` is not in general a **deterministic** (returns the same output for the same input, as opposed to probabilistic functions) **function** (which can only associate **ONE** output to an input).

As a matter of fact, many frameworks for implementing user interfaces (`Angular2`, `Ember`, `Ractive`, etc.) make use of callback procedures{^def_procedure], which, when triggered by an event, perform the corresponding action. Having the procedure directly performing the action and managing local state makes it harder to trace and debug the program execution, those issues being compounded by the concurrent nature of user interfaces. Procedures also do not compose or decompose as easily as pure functions, which limits the use of componentization techniques to reduce complexity and increase reuse. Last but not least, while generally optimized and efficient, the low-level description such frameworks offer is very far from the specification of the systems, making implementation error prone and certification activities very difficult. 

However, when the reactive relation can be made into a deterministic function, by separating events and actions from their representation, miscellaneous implementation methods borrowing at various degrees from functional programming techniques have some nice characteristics. We will focus in what follows on such implementation techniques.

{^def_procedure]: ... In the present context, a procedure is a routine, i.e. a sequence of statements, written against a runtime system, which executes them. Such procedures may or may not take arguments, may or may not return values, and may or may not perform side-effects.

### Reactive system as a joint specification of internal state updates and actions
Most of the time, it is possible to formalize a state for the reactive system such that : `(action, new state) = f(state, event)` where :

- `f` is a pure function
- `state` subsumes all the variability resulting from the environment and the reactive systems specifications, so that `f` is pure
- `f` will be termed here as the reactive function

** TODO ** : specific format for examples
EXAMPLE : given a search basic interface with an input field and a search button, and specifications such that if a search input field has only one or two characters, clicking the `search` button triggers no action, and otherwise triggers an API call, the same event (search button click) can be associated to two different actions (the symbol for no action and the API call). In one defines the state of that search interface as incorporating the number of letters in the input field, is becomes possible to purely map the search button click to one or the other action.

If we index time chronologically by a natural integer, so that the index `n` correspond to the nth event occurring, we have :

-  `(action_n, state_n+1) = f(state_n, event_n)` where :
	- `n` is the `nth` event processed by the reactive system
	- `state_n ` is the state of the reactive system **when the `nth` event is processed**
	- we hence have an implicit temporal relation here between the event occurrence and the state used to compute the reaction of the system.

Such a relation can be represented on a timelined diagrams :
```
events : k-kk
state  :01123
actions: ---c

k : letter key pressed
c : search API call
```

Those observations give rise to implementation techniques relying on a reactive function `f` which **explicitly** computes and exposes for each event the new state of the reactive system, and the action to execute. 

This is the model followed for example by `Elm`, whose `update :: Msg -> Model -> (Model, Cmd Msg)` function corresponds closely to the reactive function `f`, `Msg` to `events`, `Model` to `states`, `Cmd Msg` to `actions`. The same model can also be found in other reactive frameworks for functional languages (for instance, [purescript/pux](http://purescript-pux.org/docs/architecture/) with `foldp :: âˆ€ fx. Event -> State -> EffModel State Event fx`).

### Reactive systems as automata
By using streams to represent sequences over time, the equation is rewrote as `(actions, next(states, events)) = f(states, events)` where :
- f is a pure function, taking a stream of events to a stream of actions
- `next` is derived from the reactive system's specification
	- i.e. specifying how the state of the reactive system changes in response to an event
- `states` is a sequence where each value is the corresponding state of the reactive system at the time when an event is triggered, and subject to the equation :
	- `next(states, events) ` is such that :
		- `states[n] =def= next(states[n-1], events[n-1])` (1)

The `states` stream hence has a recursive definition. Lazily-evaluated languages will allow for expressing `states` quite naturally as a fixed point for `x -> next(x, events)`, while eagerly-evaluated  languages will directly use equation (1).

Assuming the function `next` have been determined, the reactive system behaviour is then entirely described by the following equations, which are those corresponding to a class of automata called [state transducer](http://www.cse.chalmers.se/~coquand/AUTOMATA/book.pdf)(cf. p.479) :

- `states = next(states, events)`
	- `next` will be termed here as the state transition function
- `actions = f(states, events)`

State transducers are state machines, which have an internal state, and on receiving an input, they may produce an output and update their internal state. This opens the path to implementing reactive systems with state machines. This further opens the door to a well-studied set of techniques used in that area : tracing, visualization, automatic code generation, model-based testing, formal reasoning.

Knowing that state transducers are translators between input symbols and output symbols, it seems logical that they can be used for specifying and implementing reactive systems. As a matter of fact, a reactive system translates the actions of the user on the user interface to actions on the interfaced system.

A major reference for specification and implementation techniques based on the state machine formalism can be found in <em>Programming reactive systems with state charts</em> by David Harel. 

### Reactive systems as a system of equations
The `states` stream can often conveniently be broken down in several streams, each carrying a specific portion of the reactive system's state. If that split is well done, one can write :

- `states_i = next_i(states, events)`
- `actions_i = f_i(states, events)`

Dataflow languages, such as Lucid Synchrone, use such an approach both for specification and implementation of reactive systems[^x]. The approach used by Lucid Synchrone and the like is particularly interesting for user interfaces in safety-critical domain (avionics, automotive, medicine, nuclear plants...) with stringent certification requirements. By keeping the implementation close to the specification, restricting the target implementation language and defining formal semantics for it, it is possible to guarantee liveliness and safety properties of the implemented system.

**TODO** put in bibliography
[^x]: https://www.lri.fr/~sebag/Slides/Pouzet.pdf, Functional Synchronous Programming of Reactive Systems ; https://www.di.ens.fr/~pouzet/bib/chap_lucid_synchrone_english_iste08.pdf, Synchronous Functional Programming: The Lucid Synchrone Experiment

A similar approach is taken by `cyclejs` which further collapses the `states` stream into the `actions` streams, by considering that state change is itself an action over the internal state of the system. The previous equations are then reduced to `actions_i = f_i(states, events)`[^cycle]. To keep the equivalence to the original formulation, this approach however requires to clearly and consistently define the timing of the internal state update action vs. actions on the interfaced external systems : the internal state update must be executed before the next event is processed[^instant_state_update]. In the cycle framework, `App :: Sources -> Sinks`, where `Sources` contains any necessary accessor/factory methods for the state of the system and events admitted by the system, and `Sinks` holds the actions triggered by the events.

[^cycle]: cycle however gives up on the purity of `f` in exchange for a familiar interface for compentization - components are simply functions ; but keeps discriminating between action and action representation.
[^instant_state_update]: so that we maintain `states[n] =def= next(states[n-1], events[n-1])`. If the nth event would be processed before `state[n]` is set through the equation, the `next` function could be computing an invalid state for the reactive system.

## Conclusion
User interfaces are reactive systems and as such can be specified by means of its events/actions interface with the external systems of interest, and a pure reactive function mapping the actions of the user on the user interface to actions on the interfaced system.
Implementation techniques which are closed to the specifications, or, in a best case involve code automatically generated from the specifications are less error-prone and in the best case amenable to formal verification.

# Bibliography read
https://www.di.ens.fr/~pouzet/bib/chap_lucid_synchrone_english_iste08.pdf
Synchronous Functional Programming: The Lucid Synchrone Experiment
Chapter 1.1 entire is an amazing introduction to the drivers behind the rise of synchronous languages vs. regular languages, and how they particularly were used in critical software (avionics etc.) for the closeness between specification and implementation allowing to formally guarantee properties. 
> Synchronous languages are based on the synchronous hypothesis. This hypothesis comes from the idea of separating the functional description of a system from the constraints of the architecture on which it will be executed. 
